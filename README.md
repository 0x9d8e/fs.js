# fs.js
"File system" for browser

Внимание! fs.js состоит из 50 строк и проще прочитать код, чем это описание.

## Зачем

На клиенте часто нужны какие-то данные с сервера, при том сразу после загрузки страницы (не делать же лишних запросов). Это могут быть JSON-объекты, TWIG.js (и любые другие) шаблоны, какие-то массивы, тексты и т.д. 
Распространённая практика сгенерировать на сервере js-код в котором бы нужные данные задавались бы некой переменной. Это в полне приемлемо, но несколько неудобно, когда данных много и они разнообразны. А значит передавать и получать их хорошо бы каким-то общим инструментом. Им и является fs.js. Кроме того, до тех пор, пока данные не понадобсятся они наде не парсятся т.к. fs.js хранит не инициализированные "файлы" в тегах script type="file", которые браузер даже не пытается распарсить.

## Как использовать

На сервере нужно перед закрывающим тегом </body> создать один или несколько тегов script с аттрибутом type="file" и data-path="/path/filename" (это НЕ путь к файлу на сервере, это просто идентификатор, по которому можно получить данные). Кроме того нужно указать в аттрибуте data-type одно из следующих значений:
 * string;
 * text;
 * json;
 * html;
 
От выбранного типа зависит то, в каком виде fs.js отдаст эти данные при чтении. Например, если вы выбрали string или text, то получите строку в точности такую, как казали внутри тега stript. Если вы выбрали json, то получите результат обработки содержимого тега методом JSON.parse. Если же вы указали html, то получите список DOM-элементов (без какого-либо родителя).

Разумеется не обязательно писать эти теги вручную, лучше собрать нужные данные в специальном объекте/массиве и в конце вывести в шаблонизаторе. Например:
public static function append($path, $data, $type = 'json') {
  self::$files.push(['path'=>$path, 'type'=>'$type', 'data'=>$type === 'json' ? json_encode($data) : $data]);
  return self;
}

{% for path, file in fs %}
    <script type="file" class="fs" data-path="{{path}}" data-type="{{file.type}}">{{file.data|raw}}</script>
{% endfor %}

В любом случае, что делать на сервере - ваше дело. fs.js работает на клиенте:

var user = fs.read('/user');
console.log('I\'am ' + user.name + '!');

## Как работает

Очень просто. Сразу после загрузки fs.js получает список доступных "файлов" и их типов, но не читает их содержимого.
При первом обращении к файлу fs.js в соотвествии с типом приводит его данные в нужный вид, кеширует и отдаёт. При дальнейших обращениях возвращаются уже готовые данные. Если файл так никогда и не понадобится, то и парситься он не будет. 
На самом деле проще код посмотреть.

